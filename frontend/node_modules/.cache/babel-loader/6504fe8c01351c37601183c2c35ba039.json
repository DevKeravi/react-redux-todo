{"ast":null,"code":"import { call, cancelled, put, take, takeEvery } from \"redux-saga/effects\";\nimport { END, eventChannel } from \"redux-saga\";\nimport createWebSocketConnection from \"../webSocket/socket\";\nimport { ADD_MSG, CONNECT_SOCKET, SOCKET_CONNECTION_ERROR, SOCKET_CONNECTION_SUCCESS } from \"../modules/chat\";\n\nfunction createEventChannel(socket) {\n  return eventChannel(emit => {\n    socket.onmessage = event => {\n      emit(event.data);\n    };\n\n    socket.onclose = () => {\n      emit(END);\n    };\n\n    const unsubscribe = () => {\n      socket.onmessage = null;\n    };\n\n    return unsubscribe;\n  });\n}\n\nfunction* listenForSocketMessages() {\n  let socket;\n  let socketChannel;\n\n  try {\n    socket = yield call(createWebSocketConnection);\n    socketChannel = yield call(createEventChannel, socket);\n    yield put(SOCKET_CONNECTION_SUCCESS(socket));\n\n    while (true) {\n      const payload = yield take(socketChannel);\n      const parsedData = yield JSON.parse(payload);\n\n      switch (parsedData.type) {\n        case \"added\":\n          yield put(ADD_MSG(parsedData));\n\n        default:\n          yield;\n      }\n    }\n  } catch (e) {\n    yield put(SOCKET_CONNECTION_ERROR(e));\n  } finally {\n    if (yield cancelled()) {\n      socketChannel.close();\n      socket.close();\n    } else {\n      yield put(SOCKET_CONNECTION_ERROR(\"WebSocket disconnected\"));\n    }\n  }\n}\n\nexport function* connectWebSocket() {\n  yield takeEvery(CONNECT_SOCKET, listenForSocketMessages); //DISCONNECT TODO\n\n  /*\n  yield take(SOCKET_DISCONNECT);\n  yield cancel(socketTask);\n  yield put(SOCKET_DISCONNECT_SUCCESS);\n  */\n}","map":{"version":3,"sources":["/home/cmkrosp/go/src/react-redux-todo/frontend/src/saga/webSocketSaga.js"],"names":["call","cancelled","put","take","takeEvery","END","eventChannel","createWebSocketConnection","ADD_MSG","CONNECT_SOCKET","SOCKET_CONNECTION_ERROR","SOCKET_CONNECTION_SUCCESS","createEventChannel","socket","emit","onmessage","event","data","onclose","unsubscribe","listenForSocketMessages","socketChannel","payload","parsedData","JSON","parse","type","e","close","connectWebSocket"],"mappings":"AAAA,SAASA,IAAT,EAAeC,SAAf,EAA0BC,GAA1B,EAA+BC,IAA/B,EAAqCC,SAArC,QAAsD,oBAAtD;AACA,SAASC,GAAT,EAAcC,YAAd,QAAkC,YAAlC;AACA,OAAOC,yBAAP,MAAsC,qBAAtC;AACA,SACEC,OADF,EAEEC,cAFF,EAGEC,uBAHF,EAIEC,yBAJF,QAKO,iBALP;;AAOA,SAASC,kBAAT,CAA4BC,MAA5B,EAAoC;AAClC,SAAOP,YAAY,CAAEQ,IAAD,IAAU;AAC5BD,IAAAA,MAAM,CAACE,SAAP,GAAoBC,KAAD,IAAW;AAC5BF,MAAAA,IAAI,CAACE,KAAK,CAACC,IAAP,CAAJ;AACD,KAFD;;AAGAJ,IAAAA,MAAM,CAACK,OAAP,GAAiB,MAAM;AACrBJ,MAAAA,IAAI,CAACT,GAAD,CAAJ;AACD,KAFD;;AAIA,UAAMc,WAAW,GAAG,MAAM;AACxBN,MAAAA,MAAM,CAACE,SAAP,GAAmB,IAAnB;AACD,KAFD;;AAGA,WAAOI,WAAP;AACD,GAZkB,CAAnB;AAaD;;AAED,UAAUC,uBAAV,GAAoC;AAClC,MAAIP,MAAJ;AACA,MAAIQ,aAAJ;;AAEA,MAAI;AACFR,IAAAA,MAAM,GAAG,MAAMb,IAAI,CAACO,yBAAD,CAAnB;AACAc,IAAAA,aAAa,GAAG,MAAMrB,IAAI,CAACY,kBAAD,EAAqBC,MAArB,CAA1B;AACA,UAAMX,GAAG,CAACS,yBAAyB,CAACE,MAAD,CAA1B,CAAT;;AAEA,WAAO,IAAP,EAAa;AACX,YAAMS,OAAO,GAAG,MAAMnB,IAAI,CAACkB,aAAD,CAA1B;AACA,YAAME,UAAU,GAAG,MAAMC,IAAI,CAACC,KAAL,CAAWH,OAAX,CAAzB;;AACA,cAAQC,UAAU,CAACG,IAAnB;AACE,aAAK,OAAL;AACE,gBAAMxB,GAAG,CAACM,OAAO,CAACe,UAAD,CAAR,CAAT;;AACF;AACE;AAJJ;AAMD;AACF,GAfD,CAeE,OAAOI,CAAP,EAAU;AACV,UAAMzB,GAAG,CAACQ,uBAAuB,CAACiB,CAAD,CAAxB,CAAT;AACD,GAjBD,SAiBU;AACR,QAAI,MAAM1B,SAAS,EAAnB,EAAuB;AACrBoB,MAAAA,aAAa,CAACO,KAAd;AACAf,MAAAA,MAAM,CAACe,KAAP;AACD,KAHD,MAGO;AACL,YAAM1B,GAAG,CAACQ,uBAAuB,CAAC,wBAAD,CAAxB,CAAT;AACD;AACF;AACF;;AAED,OAAO,UAAUmB,gBAAV,GAA6B;AAClC,QAAMzB,SAAS,CAACK,cAAD,EAAiBW,uBAAjB,CAAf,CADkC,CAGlC;;AACA;AACF;AACA;AACA;AACA;AACC","sourcesContent":["import { call, cancelled, put, take, takeEvery } from \"redux-saga/effects\";\nimport { END, eventChannel } from \"redux-saga\";\nimport createWebSocketConnection from \"../webSocket/socket\";\nimport {\n  ADD_MSG,\n  CONNECT_SOCKET,\n  SOCKET_CONNECTION_ERROR,\n  SOCKET_CONNECTION_SUCCESS,\n} from \"../modules/chat\";\n\nfunction createEventChannel(socket) {\n  return eventChannel((emit) => {\n    socket.onmessage = (event) => {\n      emit(event.data);\n    };\n    socket.onclose = () => {\n      emit(END);\n    };\n\n    const unsubscribe = () => {\n      socket.onmessage = null;\n    };\n    return unsubscribe;\n  });\n}\n\nfunction* listenForSocketMessages() {\n  let socket;\n  let socketChannel;\n\n  try {\n    socket = yield call(createWebSocketConnection);\n    socketChannel = yield call(createEventChannel, socket);\n    yield put(SOCKET_CONNECTION_SUCCESS(socket));\n\n    while (true) {\n      const payload = yield take(socketChannel);\n      const parsedData = yield JSON.parse(payload);\n      switch (parsedData.type) {\n        case \"added\":\n          yield put(ADD_MSG(parsedData));\n        default:\n          yield;\n      }\n    }\n  } catch (e) {\n    yield put(SOCKET_CONNECTION_ERROR(e));\n  } finally {\n    if (yield cancelled()) {\n      socketChannel.close();\n      socket.close();\n    } else {\n      yield put(SOCKET_CONNECTION_ERROR(\"WebSocket disconnected\"));\n    }\n  }\n}\n\nexport function* connectWebSocket() {\n  yield takeEvery(CONNECT_SOCKET, listenForSocketMessages);\n\n  //DISCONNECT TODO\n  /*\n  yield take(SOCKET_DISCONNECT);\n  yield cancel(socketTask);\n  yield put(SOCKET_DISCONNECT_SUCCESS);\n  */\n}\n"]},"metadata":{},"sourceType":"module"}